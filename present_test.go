package present_test

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/katexochen/present"
	"github.com/stretchr/testify/assert"
)

var cases = []struct {
	Key        string
	Plaintext  string
	Ciphertext string
}{
	{
		Key:        "00000000000000000000",
		Plaintext:  "0000000000000000",
		Ciphertext: "5579C1387B228445",
	},
	{
		Key:        "FFFFFFFFFFFFFFFFFFFF",
		Plaintext:  "0000000000000000",
		Ciphertext: "E72C46C0F5945049",
	},
	{
		Key:        "00000000000000000000",
		Plaintext:  "FFFFFFFFFFFFFFFF",
		Ciphertext: "A112FFC72F68417B",
	},
	{
		Key:        "FFFFFFFFFFFFFFFFFFFF",
		Plaintext:  "FFFFFFFFFFFFFFFF",
		Ciphertext: "3333DCD3213210D2",
	},
	// test vector for 128-bit key from pypresent.py example
	{
		Key:        "0123456789abcdef0123456789abcdef",
		Plaintext:  "0123456789abcdef",
		Ciphertext: "0e9d28685e671dd6",
	},
	// test vectors generated by generate_test_vectors.py
	{
		Key:        "00000000000000000000000000000000",
		Plaintext:  "0000000000000000",
		Ciphertext: "96db702a2e6900af",
	},
	{
		Key:        "00000000000000000000000000000000",
		Plaintext:  "FFFFFFFFFFFFFFFF",
		Ciphertext: "3c6019e5e5edd563",
	},
	{
		Key:        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		Plaintext:  "0000000000000000",
		Ciphertext: "13238c710272a5d8",
	},
	{
		Key:        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		Plaintext:  "FFFFFFFFFFFFFFFF",
		Ciphertext: "628d9fbd4218e5b4",
	},
}

const defaultRounds = 31

func decodeHex(s string) []byte {
	src := []byte(s)
	dst := make([]byte, hex.DecodedLen(len(src)))
	_, err := hex.Decode(dst, src)
	if err != nil {
		panic(err)
	}
	return dst
}

func TestNewCipher(t *testing.T) {
	t.Run("invalid key size", func(t *testing.T) {
		var key []byte
		_, err := present.NewCipher(key, defaultRounds)

		assert.Error(t, err)
		assert.Equal(t, "present: invalid key size 0", err.Error())
	})
}

func TestBlock_Encrypt(t *testing.T) {
	for _, c := range cases {
		t.Run(fmt.Sprintf("%d-bit key", len(c.Key)*4), func(t *testing.T) {
			key := decodeHex(c.Key)
			cipher, err := present.NewCipher(key, defaultRounds)
			if err != nil {
				t.Fatal(err)
			}

			plaintextBytes := decodeHex(c.Plaintext)
			plaintext := binary.BigEndian.Uint64(plaintextBytes)

			ciphertext := cipher.Encrypt(plaintext)

			expectedCiphertextBytes := decodeHex(c.Ciphertext)
			expectedCiphertext := binary.BigEndian.Uint64(expectedCiphertextBytes)
			assert.Equal(t, expectedCiphertext, ciphertext)
		})
	}
}

func TestBlock_Decrypt(t *testing.T) {
	for _, c := range cases {
		t.Run(fmt.Sprintf("%d-bit key", len(c.Key)*4), func(t *testing.T) {
			key := decodeHex(c.Key)
			cipher, err := present.NewCipher(key, defaultRounds)
			if err != nil {
				t.Fatal(err)
			}

			ciphertextBytes := decodeHex(c.Ciphertext)
			ciphertext := binary.BigEndian.Uint64(ciphertextBytes)

			plaintext := cipher.Decrypt(ciphertext)

			expectedPlaintextBytes := decodeHex(c.Plaintext)
			expectedPlaintext := binary.BigEndian.Uint64(expectedPlaintextBytes)
			assert.Equal(t, expectedPlaintext, plaintext)
		})
	}
}
